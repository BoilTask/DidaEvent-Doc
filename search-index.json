[{"content":"","date":"2024-11-03","id":0,"permalink":"/docs/overview/","summary":"","tags":[],"title":"Event"},{"content":"System Overview This is a mechanism that allows specific actions to be executed at designated times, typically including components such as event sources, event listeners, and event dispatchers.\nUsing an event system, we can more conveniently achieve interaction between two relatively independent systems.\nAfter introducing a robust event system, we can also implement logic with more \u0026ldquo;Observer Pattern\u0026rdquo; design.\nThe Observer is a behavioral design pattern that allows you to define a subscription mechanism, notifying multiple objects that observe a target object when an event occurs. â€” Observer Design Pattern (refactoringguru.cn)\nDesign Approach Our aim is to provide a more comprehensive event system, eliminating the need to create a custom event system for similar requirements.\nThis system should achieve the following goals:\nUsability Lower the system\u0026rsquo;s learning curve as much as possible Improve the readability of the logic Provide complete documentation for the system Standardize the event system\u0026rsquo;s maintenance process Enable events to be conveniently dispatched from any system Dispatch from C++ Dispatch from Blueprints Dispatch from Lua Allow any system to easily listen to events Listen from C++ Listen from Blueprints Listen from Lua Extensibility Enable the addition of new events easily Improve the rigor of the technical solution to avoid incompatible updates Completeness Handle synchronization between the DS and client Solve three-way communication between C++, Blueprints, and Lua Manage multi-listener order issues Robustness Minimize mandatory requirements when using the event system Performance Minimize unnecessary event dispatches at runtime Feature Implementation Event Definition Classes are used as event indexes to prevent misoperations caused by name-based identifiers, making it easier to expand by event in the future.\nWe define an Object type UDidaEvent as the event definition, with the event object managing all its listeners.\nWe also provide conversions between the Event class and FName, which is particularly useful for marking specific events efficiently.\nEvent key interfaces like UDidaEventLibrary::GetEventKeyByClass are available for use.\nEvent Management We define UEventSubsystem, a subclass of UGameInstanceSubsystem, as the event management class.\nThe EventSubsystem will create event instances as needed.\nEvent Triggering Basic Invocation We define a function library UDidaEventLibrary, which has a static function InvokeEvent to trigger events.\nThe trigger function should include the following parameters:\nParameter Description Outer Used as the Outer for instantiating the Payload, also used to access the EventSubsystem Event The event to trigger Channel If not None, only listeners with the same Channel or without a Channel will be triggered Payload Specifies the type of payload parameter Advanced Invocation To simplify event triggering without requiring manual payload instantiation each time, we define a more user-friendly K2Node.\nBy inheriting from UK2Node, an advanced node UK2Node_DidaInvokeEvent can be implemented.\nThe core functions are AllocateDefaultPins and ExpandNode, which define all pins on the node and their connections.\nCross-End Invocation Among all parameters of the event trigger function, Payload is user-defined, so it requires custom encoding and decoding.\nUsing UE4\u0026rsquo;s reflection mechanism, the following function can be implemented:\nFString UDidaEventPayload::MakeString_Implementation() const { FString String; FJsonObjectConverter::UStructToJsonObjectString(GetClass(), this, String, 0, 0, 0, nullptr, false); return String; }\rThis function encodes all class data into a JSON string, and similarly, a decode function can be implemented:\nvoid UDidaEventPayload::LoadString_Implementation(const FString\u0026amp; String) { TSharedPtr\u0026lt;FJsonObject\u0026gt; JsonObject; const TSharedRef\u0026lt;TJsonReader\u0026lt;\u0026gt;\u0026gt; JsonReader = TJsonReaderFactory\u0026lt;\u0026gt;::Create(String); if (!FJsonSerializer::Deserialize(JsonReader, JsonObject) || !JsonObject.IsValid()) { FString Name; if(IsValid(GetClass())) { Name = GetClass()-\u0026gt;GetName(); } LOG_CATEGORY_WARN(LogDidaEvent, \u0026#34;{} Failed\u0026#34;, Name); return; } FJsonObjectConverter::JsonObjectToUStruct(JsonObject.ToSharedRef(), GetClass(), this); }\rWith this design, the Payload can be transmitted over the network, while allowing developers to define custom encoding and decoding rules.\nEvent Listening An IDidaEventListenerInterface is defined to provide generic functions for listeners, primarily for RegisterListener and UnregisterListener functions.\nWhen registered, the listener is added to the DidaEvent\u0026rsquo;s listener list for lookup during triggering.\nPerformance Optimization Most listeners only care about specific triggers, so we introduce a Channel mechanism.\nOnly events with the same Channel as the listener will trigger it (all Channels are triggered if no Channel is specified).\nInvoking with None will trigger all listeners (regardless of their Channel). Invoking with a Channel will only trigger listeners with the same Channel. Listening with None will receive all invokes (regardless of their Channel). Listening with a Channel will receive invokes with the same Channel. The interface UDidaEventLibrary::GetObjectChannel is provided to dynamically generate Channels using Objects.\nListener Order Generally, multiple listeners do not require specific ordering, as they should execute independently.\nIn some cases, however, we may prefer listeners to trigger in a defined order, so we introduce the ListenerPriority mechanism.\nListeners should implement the PriorityLayer for hierarchical priorities and ListenerPriority for numerical priorities.\nThe priority dictates the order of event triggers, with layers sorted first, then numerical values, where higher numbers have higher priority.\nTo maintain clarity, the following special layers are predefined:\nSemantic Layer Translated As Default Layer_5 Low Layer_3 High Layer_7 Use layers to handle multi-listener order issues whenever possible, as relying solely on numbers may lead to maintenance difficulties.\nC++-Related Logic Usually, call the relevant functions in the DidaEventLibrary function library, passing in the required parameters.\nUDidaEventLibrary::CreateListenerVariable creates a listener UDidaEventLibrary::InvokeEvent triggers an event UDidaEventLibrary::SpawnDidaEventPayload\u0026lt;UDidaEventPayload_XXX\u0026gt; creates a payload UDidaEventLibrary::GetObjectChannel gets the Channel of an Object ","date":"2024-11-03","id":1,"permalink":"/docs/overview/introduction/","summary":"\u003ch2 id=\"system-overview\"\u003eSystem Overview\u003c/h2\u003e\n\u003cp\u003eThis is a mechanism that allows specific actions to be executed at designated times, typically including components such as event sources, event listeners, and event dispatchers.\u003c/p\u003e","tags":[],"title":"Introduction"},{"content":"Purchase You can purchase it on the Unreal Engine Marketplace.\n","date":"2024-11-03","id":2,"permalink":"/docs/overview/install/","summary":"\u003ch2 id=\"purchase\"\u003ePurchase\u003c/h2\u003e\n\u003cp\u003eYou can purchase it on the \u003ca href=\"https://www.unrealengine.com/marketplace/en-US/product/didaevent\"\u003eUnreal Engine Marketplace\u003c/a\u003e.\u003c/p\u003e","tags":[],"title":"Install"},{"content":"1.0.0 Uploaded the basic implementation version.\nProvided event definition Provided event broadcast Provided event listening Provided channel mechanism ","date":"2024-11-03","id":3,"permalink":"/docs/overview/changelog/","summary":"\u003ch2 id=\"100\"\u003e1.0.0\u003c/h2\u003e\n\u003cp\u003eUploaded the basic implementation version.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProvided event definition\u003c/li\u003e\n\u003cli\u003eProvided event broadcast\u003c/li\u003e\n\u003cli\u003eProvided event listening\u003c/li\u003e\n\u003cli\u003eProvided channel mechanism\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"Changelog"},{"content":"","date":"2024-11-03","id":4,"permalink":"/docs/tutorial/","summary":"","tags":[],"title":"Guide"},{"content":"With the following steps, we can quickly define and use an event.\nDefine an Event To create an event, we need to define a subclass based on UDidaEvent, which can be a C++ class or a blueprint class.\nBroadcast the Event In the blueprint, you can call the DidaInvokeEvent node to trigger the event.\nListen to the Event In an Actor, you can use DidaEventListenerComponent to listen for events.\nSet the Componentâ€™s properties to configure the events you want to listen to.\nUse the Delegate on the Component to define the logic that will run when the event is received.\nCongratulations ðŸŽ‰ Following the steps above, we have implemented a feature:\nWhen pressing a key, the character object outputs a log message.\n","date":"2024-11-03","id":5,"permalink":"/docs/tutorial/quick/","summary":"\u003cp\u003eWith the following steps, we can quickly define and use an event.\u003c/p\u003e\n\u003ch2 id=\"define-an-event\"\u003eDefine an Event\u003c/h2\u003e\n\u003cp\u003eTo create an event, we need to define a subclass based on \u003ccode\u003eUDidaEvent\u003c/code\u003e, which can be a \u003ccode\u003eC++\u003c/code\u003e class or a blueprint class.\u003c/p\u003e","tags":[],"title":"Quick Start"},{"content":"","date":"2024-11-03","id":6,"permalink":"/docs/concept/","summary":"","tags":[],"title":"Concepts"},{"content":"The following nodes are available for triggering events:\nNode Name Description DidaInvokeEvent The most commonly used event trigger node; also used to access the EventSubsystem For example, you can use the DidaInvokeEvent node directly within a blueprint.\nBelow is an explanation of the relevant parameters:\nParameter Description Outer Used as the Outer to instantiate the Payload, as well as to access the EventSubsystem. Event The event to be triggered. Channel If not None, only listeners with either no channel or the same channel will be triggered. Payload Specifies the type of payload parameters to be used. Once a payload is selected, parameters defined with meta=(ExposeOnSpawn) in the payload will be listed.\nWhen the node executes, it instantiates the payload and assigns the specified parameters, with the provided object as its Outer.\nAdditionally, UDidaEventLibrary provides non-K2Node versions of various functions, which can be used as needed.\n","date":"2024-11-03","id":7,"permalink":"/docs/concept/invoke/","summary":"\u003cp\u003eThe following nodes are available for triggering events:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eNode Name\u003c/th\u003e\n          \u003cth\u003eDescription\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaInvokeEvent\u003c/td\u003e\n          \u003ctd\u003eThe most commonly used event trigger node; also used to access the EventSubsystem\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eFor example, you can use the \u003ccode\u003eDidaInvokeEvent\u003c/code\u003e node directly within a blueprint.\u003c/p\u003e","tags":[],"title":"Invoke Event"},{"content":"Listening Methods Currently, the following options are available for event listeners:\nType Description DidaEventListenerComponent Can be added to any object that allows components, listens for events at BeginPlay based on configuration. DidaEventListenerWidget Can be added to any widget-supporting object, listens for events at Construct based on configuration. DidaEventListenerVariable A versatile listener that can be placed anywhere and requires manual function calls to bind listeners. DidaEventMultiListenerComponent Similar to DidaEventListenerComponent, but allows for multiple event listeners. DidaEventMultiListenerWidget Similar to DidaEventListenerWidget, but allows for multiple event listeners. DidaEventMultiListenerVariable Similar to DidaEventListenerVariable, but allows for multiple event listeners. For example, you can create a listener using CreateListenerVariable.\nIf you create a ListenerVariable, make sure to hold its reference to prevent it from being garbage collected, which would stop it from receiving events.\nBelow is an explanation of the relevant parameters:\nParameter Description Outer Used as the Outer for instantiating the variable, and to access the EventSubsystem. Event The event to be triggered. OnEventInvoked Callback function invoked after the event is triggered. Channel The channel being listened to; only events with either no channel or the same channel will trigger. PriorityLayer The priority layer, which determines priority together with priority size. ListenerPriority The priority size, which determines priority together with priority layer. bShouldRegisterOnStart Whether to bind the listener upon registration; otherwise, you can manually call RegisterChannelListener, etc. Priority determines the order in which multiple listeners are triggered for an event; higher-priority listeners are triggered first.\nFor clarity, use layers to define priority size whenever possible.\nPriority will first check the priority enumeration; the higher the enum value, the higher the priority.\nImportant Notes A single DidaEventListenerInterface cannot listen to the same event multiple times. Re-registering the listener has no effect, even with different channels. If necessary, unregister the previous listener or create multiple instances.\nA DidaEventListenerInterface can listen to multiple events, which triggers OnEventCalled for each event. This can complicate logic maintenance, so it is recommended that each DidaEventListenerInterface corresponds to one event. For multiple events, consider using the DidaEventMultiListenerXXX interface.\nAdvanced Usage To support advanced listening needs or avoid creating additional objects, an existing object can be set as a listener.\nSimply add the DidaEventListenerInterface to any UObject-based class and implement the necessary logic:\nAdd the DidaEventListenerInterface interface to the class. Implement GetListenerName to specify the listenerâ€™s name, which can simply return GetName(). Implement OnEventCalled to handle event callbacks. Call UDidaEventLibrary::RegisterListener to register the listener at the appropriate time. Call UDidaEventLibrary::UnregisterListener to unregister the listener when necessary. ","date":"2024-11-03","id":8,"permalink":"/docs/concept/listener/","summary":"\u003ch2 id=\"listening-methods\"\u003eListening Methods\u003c/h2\u003e\n\u003cp\u003eCurrently, the following options are available for event listeners:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eType\u003c/th\u003e\n          \u003cth\u003eDescription\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventListenerComponent\u003c/td\u003e\n          \u003ctd\u003eCan be added to any object that allows components, listens for events at BeginPlay based on configuration.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventListenerWidget\u003c/td\u003e\n          \u003ctd\u003eCan be added to any widget-supporting object, listens for events at Construct based on configuration.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventListenerVariable\u003c/td\u003e\n          \u003ctd\u003eA versatile listener that can be placed anywhere and requires manual function calls to bind listeners.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventMultiListenerComponent\u003c/td\u003e\n          \u003ctd\u003eSimilar to DidaEventListenerComponent, but allows for multiple event listeners.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventMultiListenerWidget\u003c/td\u003e\n          \u003ctd\u003eSimilar to DidaEventListenerWidget, but allows for multiple event listeners.\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventMultiListenerVariable\u003c/td\u003e\n          \u003ctd\u003eSimilar to DidaEventListenerVariable, but allows for multiple event listeners.\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eFor example, you can create a listener using \u003ccode\u003eCreateListenerVariable\u003c/code\u003e.\u003c/p\u003e","tags":[],"title":"Listening to Events"},{"content":"Mechanism Overview To address cases where some listeners do not need to respond to all triggers of a specific event, a channel mechanism is introduced.\nIn principle, only events broadcasted and registered with the same channel will be triggered (if no channel is specified, all will be triggered).\nInvoking with None will trigger all listeners (regardless of whether the listener has a specific channel). Invoking with a specific channel will trigger only those listeners registered to the same channel. A listener set to None will receive all invokes (regardless of the invoke channel). A listener registered to a specific channel will receive only those invokes with the same channel. Channel Assignment The UDidaEventLibrary::GetObjectChannel interface provides a way to dynamically generate channels using an object.\nBy default, this function will return the same key for identical objects, allowing events from the same channel to be specified for listening.\nIn most cases, channels are defined by the information of a particular event. Thus, even if channels share the same name, they will not conflict across different events.\nOverriding Channels An object can inherit IDidaEventChannelInterface to override the ReplaceObjectChannel interface and change the way channels are computed. Note that if the function returns false, the default conversion method will still be applied.\nFor example, a controllerâ€™s calculation could be defined to be based on PlayerId, which would conveniently allow cross-end channel interaction.\nSpecial calculations currently available are documented in: Special Channel Rules Summary\nNote that if the channel is dynamic, the logic dependent on the channel must handle order and timing issues appropriately.\nMagic Channels To address situations where listeners need to specify channels before runtime, which can limit the applicability of setting default values for event listeners, a \u0026ldquo;magic channel\u0026rdquo; mechanism is introduced. This mechanism can also be used directly at runtime.\nThe basic principle is: set a special category of Name; if these Names are detected during listener creation, they will automatically convert to another channel.\nMagic channels allow default values to be assigned directly to event listeners, avoiding the need to specify them at runtime.\nBe mindful of the registration timing and the order of dependencies between related magic channels to avoid cases where required objects are not available at listener creation.\n","date":"2024-11-03","id":9,"permalink":"/docs/concept/channel/","summary":"\u003ch2 id=\"mechanism-overview\"\u003eMechanism Overview\u003c/h2\u003e\n\u003cp\u003eTo address cases where some listeners do not need to respond to all triggers of a specific event, a channel mechanism is introduced.\u003c/p\u003e","tags":[],"title":"Event Channel"},{"content":"Basic Usage The payload is used to carry additional parameters when an event is triggered. It is defined by inheriting from UDidaEventPayload.\nAt the time of triggering, payload parameters can be set through the node.\nWhen listening, cast to the target type to retrieve payload parameters.\nCreating a Payload If itâ€™s necessary to instantiate a payload manually due to specific requirements, you can use the static function UDidaEventLibrary::SpawnDidaEventPayload from the event function library. Once created, use the libraryâ€™s static function UDidaEventLibrary::InvokeEvent to trigger the event.\nOverloading Serialization The payload supports overloading the following two functions:\nParameter Description MakeString Generates a string based on payload data LoadString Assigns payload data from a string These functions are called during RPC and TCP event transmission for encoding payload data.\nBy default, data is converted to a JSON string based on reflection information, but special types, such as pointers, may require custom encoding and decoding logic. Implementing these functions enables seamless network transmission of events.\nPayload Recycling To optimize payload creation overhead, a recycling mechanism for payloads is available. This is disabled by default to prevent exceptions due to incorrect recycling function implementations. If you wish to enable it, create a subclass based on UDidaEventPayloadRecyclable and implement NativeOnRecycled or K2_OnRecycled.\nThe payload will attempt to retrieve from the recycle pool upon creation and be recycled after the event is invoked.\nEnsure proper implementation of the recycling functions to avoid call exceptions or prolonged object retention. Also, avoid using the payload after it has been recycled.\n","date":"2024-11-03","id":10,"permalink":"/docs/concept/payload/","summary":"\u003ch2 id=\"basic-usage\"\u003eBasic Usage\u003c/h2\u003e\n\u003cp\u003eThe payload is used to carry additional parameters when an event is triggered. It is defined by inheriting from \u003ccode\u003eUDidaEventPayload\u003c/code\u003e.\u003c/p\u003e","tags":[],"title":"Event Payload"},{"content":"","date":"2024-11-03","id":11,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":12,"permalink":"/","summary":"","tags":[],"title":"DidaEvent"},{"content":"","date":"0001-01-01","id":13,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":14,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":15,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]