[{"content":"系统简述 一种允许在特定时机执行指定操作的机制，通常需要包括事件源、事件监听、事件调度等部分。\n通过事件系统，我们可以更为方便地实现两个较为独立的系统之间的调用。\n而引入一个好用的事件系统之后，我们也可以更多的使用“观察者模式”设计逻辑。\n观察者是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。——观察者设计模式 (refactoringguru.cn)\n设计思路 我们需要提供一个更为完善的事件系统，从而达到实现类似需求时，无需再建立功能向的事件系统。\n该系统应该实现以下几点目标：\n易用性 应尽可能减少系统的理解门槛 提高逻辑的可读性 完善系统的相关文档 规范事件系统的维护流程 应能便捷的由某一系统发送事件 C++中发送 蓝图中发送 Lua中发送 应能便捷的由某一系统监听事件 C++中监听 蓝图中监听 Lua中监听 扩展性 应能便捷的扩展一种新事件 提高技术方案的严谨性避免出现不兼容更新 全面性 应能处理DS与客户端的同步问题 应能解决C++\u0026amp;蓝图\u0026amp;Lua的三方通信 应能处理多监听者顺序问题 鲁棒性 尽量减少使用事件系统时的强制要求 性能 应在运行时减少不必要的事件分发] 功能实现 事件定义 使用Class作为指定事件的一种索引，防止纯Name式带来的误操作，同时也方便后续以Event为单位扩展。\n我们定义一个Object类型UDidaEvent作为事件的定义，事件对象管理他的所有监听器。\n同时我们提供了Event类与FName的转换，这对于高效标记某一事件较为使用。\n可以调用UDidaEventLibrary::GetEventKeyByClass等EventKey接口来使用。\n事件管理 我们定义一个以UGameInstanceSubsystem为基类的UEventSubsystem作为事件的管理类。\nEventSubsystem会在需要的时候创建事件的实例。\n事件触发 基础调用 定义了一个函数库UDidaEventLibrary，他具有触发事件的静态函数InvokeEvent。\n触发函数应具有如下参数：\n参数 描述 Outer 用作实例化Payload的Outer，同时会被用作获取EventSubsystem Event 所需要触发的事件 Channel 如果不为None，只有不设Channel或相同Channel的监听会被触发 Payload 需要指定的载荷参数的类型 高级调用 如果每次都需要开发者自己实例化Payload会让触发事件较为复杂，所以我们定义一个更好用的K2Node。\n继承UK2Node可以自己实现一个高级结点UK2Node_DidaInvokeEvent。\n核心函数为AllocateDefaultPins与ExpandNode，他们分别定义了结点的所有Pin与Pin之间的连接关系。\n跨端调用 在事件触发函数的所有参数中，因为Payload是开发者自定义的，所以其需要设计数据如何编码解码。\n通过UE4的反射机制可以实现如下函数：\nFString UDidaEventPayload::MakeString_Implementation() const { FString String; FJsonObjectConverter::UStructToJsonObjectString(GetClass(), this, String, 0, 0, 0, nullptr, false); return String; }\r他会把类中所有数据编码为一个Json字符串，同理可以实现解码函数：\nvoid UDidaEventPayload::LoadString_Implementation(const FString\u0026amp; String) { TSharedPtr\u0026lt;FJsonObject\u0026gt; JsonObject; const TSharedRef\u0026lt;TJsonReader\u0026lt;\u0026gt;\u0026gt; JsonReader = TJsonReaderFactory\u0026lt;\u0026gt;::Create(String); if (!FJsonSerializer::Deserialize(JsonReader, JsonObject) || !JsonObject.IsValid()) { FString Name; if(IsValid(GetClass())) { Name = GetClass()-\u0026gt;GetName(); } LOG_CATEGORY_WARN(LogDidaEvent, \u0026#34;{} Failed\u0026#34;, Name); return; } FJsonObjectConverter::JsonObjectToUStruct(JsonObject.ToSharedRef(), GetClass(), this); }\r通过这种设计，可以实现Payload在网络上的传输，同时提供了开发者自定义编码解码规则的空间。\n事件监听 定义了一个IDidaEventListenerInterface作为触发器通用函数的定义，主要用于RegisterListener与UnregisterListener函数。\n当注册时，会把监听器注册在DidaEvent的监听器列表中以供触发时查找。\n性能优化 考虑大部分监听器只关心自己所需关心的触发，因此引入了Channel频道机制。\n思路上只有注册与广播相同Channel的事件会被触发（不指定Channel应所有都触发）。\nInvoke一个None，所有Listen都会被触发（无论Listen有没有指定Channel） Invoke一个Channel，相同Channel的Listen会被触发 Listen一个None，所有Invoke都会接收（无论Invoke有没有指定Channel） Listen一个Channel，相同Channel的Invoke会接收 对应的提供了如何使用Object来动态生成Channel的接口UDidaEventLibrary::GetObjectChannel。\n监听器顺序 在大部分时候我们不需要关系多个监听器之间的顺序，他们应该是独立执行的。\n但在有些时候，对于同一时间我们喜欢触发一部分监听器时他们能按定义的顺序执行，因此在监听器中引入了ListenerPriority机制。\nListener应实现优先级层级PriorityLayer与优先级数值ListenerPriority。\n会根据优先级进行排序来决定触发事件的顺序，排序时会先根据优先级分层排序，再根据优先级大小排序，枚举值越大优先级越大，优先级大的会被排在前面。\n为了语义清晰，目前定义了几个特殊的层，除了这几个特殊的分层，其余根据枚举值的大小来确认优先级。\n语义化分层 转义为 Default Layer_5 Low Layer_3 High Layer_7 当添加这些分层时，会被转译为对应的分层。\n为了定义清晰，应优先使用分层来解决多监听器顺序问题，避免仅使用数值导致的难以维护问题。\nC++相关逻辑 一般使用DidaEventLibrary函数库中的相关函数来调用，传入所需参数即可。\nUDidaEventLibrary::CreateListenerVariable创建一个监听器 UDidaEventLibrary::InvokeEvent触发一个事件 UDidaEventLibrary::SpawnDidaEventPayload\u0026lt;UDidaEventPayload_XXX\u0026gt;创建载荷 UDidaEventLibrary::GetObjectChannel获取Object的Channel ","date":"2024-11-03","id":0,"permalink":"/zh/docs/overview/introduction/","summary":"\u003ch2 id=\"系统简述\"\u003e系统简述\u003c/h2\u003e\n\u003cp\u003e一种允许在特定时机执行指定操作的机制，通常需要包括事件源、事件监听、事件调度等部分。\u003c/p\u003e\n\u003cp\u003e通过事件系统，我们可以更为方便地实现两个较为独立的系统之间的调用。\u003c/p\u003e\n\u003cp\u003e而引入一个好用的事件系统之后，我们也可以更多的使用“观察者模式”设计逻辑。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e观察者是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。——\u003ca href=\"https://refactoringguru.cn/design-patterns/observer\"\u003e观察者设计模式 (refactoringguru.cn)\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"设计思路\"\u003e设计思路\u003c/h2\u003e\n\u003cp\u003e我们需要提供一个更为完善的事件系统，从而达到实现类似需求时，无需再建立功能向的事件系统。\u003c/p\u003e\n\u003cp\u003e该系统应该实现以下几点目标：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e易用性\n\u003cul\u003e\n\u003cli\u003e应尽可能减少系统的理解门槛\n\u003cul\u003e\n\u003cli\u003e提高逻辑的可读性\u003c/li\u003e\n\u003cli\u003e完善系统的相关文档\u003c/li\u003e\n\u003cli\u003e规范事件系统的维护流程\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e应能便捷的由某一系统发送事件\n\u003cul\u003e\n\u003cli\u003eC++中发送\u003c/li\u003e\n\u003cli\u003e蓝图中发送\u003c/li\u003e\n\u003cli\u003eLua中发送\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e应能便捷的由某一系统监听事件\n\u003cul\u003e\n\u003cli\u003eC++中监听\u003c/li\u003e\n\u003cli\u003e蓝图中监听\u003c/li\u003e\n\u003cli\u003eLua中监听\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e扩展性\n\u003cul\u003e\n\u003cli\u003e应能便捷的扩展一种新事件\u003c/li\u003e\n\u003cli\u003e提高技术方案的严谨性避免出现不兼容更新\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e全面性\n\u003cul\u003e\n\u003cli\u003e应能处理DS与客户端的同步问题\u003c/li\u003e\n\u003cli\u003e应能解决C++\u0026amp;蓝图\u0026amp;Lua的三方通信\u003c/li\u003e\n\u003cli\u003e应能处理多监听者顺序问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e鲁棒性\n\u003cul\u003e\n\u003cli\u003e尽量减少使用事件系统时的强制要求\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e性能\n\u003cul\u003e\n\u003cli\u003e应在运行时减少不必要的事件分发]\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"功能实现\"\u003e功能实现\u003c/h2\u003e\n\u003ch3 id=\"事件定义\"\u003e事件定义\u003c/h3\u003e\n\u003cp\u003e使用Class作为指定事件的一种索引，防止纯Name式带来的误操作，同时也方便后续以Event为单位扩展。\u003c/p\u003e","tags":[],"title":"实现说明"},{"content":"","date":"2024-11-03","id":1,"permalink":"/zh/docs/overview/","summary":"","tags":[],"title":"事件系统"},{"content":"购买 可前往Unreal Engine Marketplace购买。\n","date":"2024-11-03","id":2,"permalink":"/zh/docs/overview/install/","summary":"\u003ch2 id=\"购买\"\u003e购买\u003c/h2\u003e\n\u003cp\u003e可前往\u003ca href=\"https://www.unrealengine.com/marketplace/zh-CN/product/didaevent\"\u003eUnreal Engine Marketplace\u003c/a\u003e购买。\u003c/p\u003e","tags":[],"title":"安装"},{"content":"1.0.0 上传基础实现版本。\n提供了事件定义 提供了事件广播 提供了事件监听 提供了频道机制 ","date":"2024-11-03","id":3,"permalink":"/zh/docs/overview/changelog/","summary":"\u003ch2 id=\"100\"\u003e1.0.0\u003c/h2\u003e\n\u003cp\u003e上传基础实现版本。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e提供了事件定义\u003c/li\u003e\n\u003cli\u003e提供了事件广播\u003c/li\u003e\n\u003cli\u003e提供了事件监听\u003c/li\u003e\n\u003cli\u003e提供了频道机制\u003c/li\u003e\n\u003c/ul\u003e","tags":[],"title":"更新日志"},{"content":"通过以下步骤，我们能快速定义和使用一个事件。\n定义事件 要创建一个事件，我们需要定义一个以UDidaEvent为基类的子类，可以是C++类也可以是蓝图类。\n广播事件 在蓝图中可以调用DidaInvokeEvent结点触发事件。\n监听事件 在Actor中可以使用DidaEventListenerComponent来监听事件。\n设置Component的属性，配置所需监听的事件。\n使用Component上的Delegate编写收到事件后的逻辑。\n恭喜 🎉通过如上步骤我们实现了一个功能：\n在按键时，角色对象输出了一条日志。\n","date":"2024-11-03","id":4,"permalink":"/zh/docs/tutorial/quick/","summary":"\u003cp\u003e通过以下步骤，我们能快速定义和使用一个事件。\u003c/p\u003e\n\u003ch2 id=\"定义事件\"\u003e定义事件\u003c/h2\u003e\n\u003cp\u003e要创建一个事件，我们需要定义一个以\u003ccode\u003eUDidaEvent\u003c/code\u003e为基类的子类，可以是\u003ccode\u003eC++\u003c/code\u003e类也可以是蓝图类。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/quick-declare-event.gif\"\r\n  width=\"700\"\r\n  height=\"700\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"quick-declare-event\"id=\"h-rh-i-0\"\r\n/\u003e\u003c/p\u003e\n\u003ch2 id=\"广播事件\"\u003e广播事件\u003c/h2\u003e\n\u003cp\u003e在蓝图中可以调用\u003ccode\u003eDidaInvokeEvent\u003c/code\u003e结点触发事件。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/quick-invoke-event.gif\"\r\n  width=\"650\"\r\n  height=\"400\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"quick-invoke-event\"id=\"h-rh-i-1\"\r\n/\u003e\u003c/p\u003e\n\u003ch2 id=\"监听事件\"\u003e监听事件\u003c/h2\u003e\n\u003cp\u003e在\u003ccode\u003eActor\u003c/code\u003e中可以使用\u003ccode\u003eDidaEventListenerComponent\u003c/code\u003e来监听事件。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/quick-create-listener.gif\"\r\n  width=\"350\"\r\n  height=\"350\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"quick-create-listener\"id=\"h-rh-i-2\"\r\n/\u003e\u003c/p\u003e\n\u003cp\u003e设置Component的属性，配置所需监听的事件。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/quick-set-listener-event.gif\"\r\n  width=\"450\"\r\n  height=\"450\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"quick-set-listener-event\"id=\"h-rh-i-3\"\r\n/\u003e\u003c/p\u003e\n\u003cp\u003e使用Component上的Delegate编写收到事件后的逻辑。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/quick-set-listener-callback.gif\"\r\n  width=\"1300\"\r\n  height=\"750\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"quick-set-listener-callback\"id=\"h-rh-i-4\"\r\n/\u003e\u003c/p\u003e\n\u003ch2 id=\"恭喜\"\u003e恭喜\u003c/h2\u003e\n\u003cp\u003e🎉通过如上步骤我们实现了一个功能：\u003c/p\u003e\n\u003cp\u003e在按键时，角色对象输出了一条日志。\u003c/p\u003e","tags":[],"title":"快速编写一个事件"},{"content":"","date":"2024-11-03","id":5,"permalink":"/zh/docs/tutorial/","summary":"","tags":[],"title":"使用指南"},{"content":"","date":"2024-11-03","id":6,"permalink":"/zh/docs/concept/","summary":"","tags":[],"title":"概念说明"},{"content":"目前提供了如下触发事件的结点：\n结点名 描述 DidaInvokeEvent 最常用的触发事件的结点，同时会被用作获取EventSubsystem 以DidaInvokeEvent为例，通过直接在一个蓝图中找到DidaInvokeEvent结点即可使用。\n下面是相关参数的说明：\n参数 描述 Outer 用作实例化Payload的Outer，同时会被用作获取EventSubsystem Event 所需要触发的事件 Channel 如果不为None，只有不设Channel或相同Channel的监听会被触发 Payload 需要指定的载荷参数的类型 当选择一个Payload之后，会列出Payload中定义的meta=(ExposeOnSpawn)的参数。\n结点运行的时候实例化Payload并赋值相关参数，其Outer为所传Object。\n同时在UDidaEventLibrary中有各个函数的非K2Node版本，可供根据自身需要调用。\n","date":"2024-11-03","id":7,"permalink":"/zh/docs/concept/invoke/","summary":"\u003cp\u003e目前提供了如下触发事件的结点：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e结点名\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaInvokeEvent\u003c/td\u003e\n          \u003ctd\u003e最常用的触发事件的结点，同时会被用作获取EventSubsystem\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e以DidaInvokeEvent为例，通过直接在一个蓝图中找到DidaInvokeEvent结点即可使用。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/concept-invoke-event_hu5248449951311072720.webp\"\r\n  width=\"307\"\r\n  height=\"318\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"concept-invoke-event\"id=\"h-rh-i-0\"\r\n/\u003e\u003c/p\u003e\n\u003cp\u003e下面是相关参数的说明：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e参数\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eOuter\u003c/td\u003e\n          \u003ctd\u003e用作实例化Payload的Outer，同时会被用作获取EventSubsystem\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eEvent\u003c/td\u003e\n          \u003ctd\u003e所需要触发的事件\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eChannel\u003c/td\u003e\n          \u003ctd\u003e如果不为None，只有不设Channel或相同Channel的监听会被触发\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003ePayload\u003c/td\u003e\n          \u003ctd\u003e需要指定的载荷参数的类型\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e当选择一个Payload之后，会列出Payload中定义的meta=(ExposeOnSpawn)的参数。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/concept-invoke-payload_hu1276233845258907778.webp\"\r\n  width=\"384\"\r\n  height=\"442\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"concept-invoke-payload\"id=\"h-rh-i-1\"\r\n/\u003e\u003c/p\u003e","tags":[],"title":"广播事件"},{"content":"监听方式 目前主要提供了以下几种监听事件的方式：\n类型 描述 DidaEventListenerComponent 可以添加到一个允许添加Component的对象，会在BeginPlay的时候根据配置监听事件 DidaEventListenerWidget 可以添加到一个允许添加Widget的对象，会在Construct的时候根据配置监听事件 DidaEventListenerVariable 最为通用的一个监听器，允许在任何地方放置，需要自己调用函数绑定监听 DidaEventMultiListenerComponent 比起DidaEventListenerComponent，它允许监听多个事件 DidaEventMultiListenerWidget 比起DidaEventListenerWidget，它允许监听多个事件 DidaEventMultiListenerVariable 比起DidaEventListenerVariable，它允许监听多个事件 以DidaEventListenerVariable为例，可以通过CreateListenerVariable创建一个监听器。\n如果创建了一个ListenerVariable，那么还应持有他的引用，防止Listener被GC而无法收到事件。\n下面是相关参数的说明：\n参数 描述 Outer 用作实例化Variable的Outer，同时会被用作获取EventSubsystem Event 所需要触发的事件 OnEventInvoked 触发事件后的回调 Channel 所监听的频道，只有不设Channel或相同Channel的事件会被触发 PriorityLayer 优先级层级，会根据层级与优先级大小判断优先级 ListenerPriority 优先级大小，会根据层级与优先级大小判断优先级 bShouldRegisterOnStart 是否在注册时绑定监听，否则可手动调用RegisterChannelListener等 优先级决定了事件触发多个监听器时的顺序，优先级大的会被先触发\n为了定义清晰，应优先使用分层来定义优先级大小\n会先判断优先级枚举，枚举值越大则优先级越大\n注意事项 不允许同一个DidaEventListenerInterface多次监听同一事件，重复注册监听无效。即使注册时设置不同Channel也不允许，真的需要可先解除旧的注册或创建多个实例。\n允许一个DidaEventListenerInterface监听多个事件，此时每个事件触发都会调用OnEventCalled，会导致逻辑较难维护，因此还是推荐一个DidaEventListenerInterfac对应一个Event。如果真的需要监听多个事件，可以使用DidaEventMultiListenerXXX相关接口。\n高级用法 为了更高级的监听用途，或者不想创建额外的对象，目前允许把一个现有的对象设置为监听器。\n只需要把一个基于UObject的类加上DidaEventListenerInterface接口，并实现相关逻辑即可。\n将类加上DidaEventListenerInterface接口 实现GetListenerName用于标识监听器名称，可以直接返回GetName() 实现OnEventCalled用于接收事件调用 在合适的时机调用UDidaEventLibrary::RegisterListener注册监听器 在合适的时机调用UDidaEventLibrary::UnregisterListener注销监听器 ","date":"2024-11-03","id":8,"permalink":"/zh/docs/concept/listener/","summary":"\u003ch2 id=\"监听方式\"\u003e监听方式\u003c/h2\u003e\n\u003cp\u003e目前主要提供了以下几种监听事件的方式：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e类型\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventListenerComponent\u003c/td\u003e\n          \u003ctd\u003e可以添加到一个允许添加Component的对象，会在BeginPlay的时候根据配置监听事件\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventListenerWidget\u003c/td\u003e\n          \u003ctd\u003e可以添加到一个允许添加Widget的对象，会在Construct的时候根据配置监听事件\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventListenerVariable\u003c/td\u003e\n          \u003ctd\u003e最为通用的一个监听器，允许在任何地方放置，需要自己调用函数绑定监听\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventMultiListenerComponent\u003c/td\u003e\n          \u003ctd\u003e比起DidaEventListenerComponent，它允许监听多个事件\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventMultiListenerWidget\u003c/td\u003e\n          \u003ctd\u003e比起DidaEventListenerWidget，它允许监听多个事件\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eDidaEventMultiListenerVariable\u003c/td\u003e\n          \u003ctd\u003e比起DidaEventListenerVariable，它允许监听多个事件\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e以DidaEventListenerVariable为例，可以通过CreateListenerVariable创建一个监听器。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/concept-listener-variable_hu3318196229432763350.webp\"\r\n  width=\"299\"\r\n  height=\"294\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"concept-listener-variable\"id=\"h-rh-i-0\"\r\n/\u003e\u003c/p\u003e\n\u003cdiv class=\"callout callout-tip d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/rocket svg-inline callout-icon me-2 mb-3\" id=\"svg-rocket\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M4 13a8 8 0 0 1 7 7a6 6 0 0 0 3 -5a9 9 0 0 0 6 -8a3 3 0 0 0 -3 -3a9 9 0 0 0 -8 6a6 6 0 0 0 -5 3\" /\u003e\n  \u003cpath d=\"M7 14a6 6 0 0 0 -3 6a6 6 0 0 0 6 -3\" /\u003e\n  \u003cpath d=\"M15 9m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \r\n    \u003cdiv class=\"callout-body\"\u003e\r\n      \u003cp\u003e如果创建了一个ListenerVariable，那么还应持有他的引用，防止Listener被GC而无法收到事件。\u003c/p\u003e","tags":[],"title":"监听事件"},{"content":"机制说明 为了解决某些监听器不是需要监听所有某一事件的触发，所以引入了频道Channel机制。\n思路上只有注册与广播相同Channel的事件会被触发（不指定Channel应所有都触发）。\nInvoke一个None，所有Listen都会被触发（无论Listen有没有指定Channel） Invoke一个Channel，相同Channel的Listen会被触发 Listen一个None，所有Invoke都会接收（无论Invoke有没有指定Channel） Listen一个Channel，相同Channel的Invoke会接收 频道分配 对应的提供了如何使用Object来动态生成Channel的接口UDidaEventLibrary::GetObjectChannel。\n默认情况下只要传入相同的对象，该函数会返回相同的Key，从而可以实现可以指定监听来自同一频道的事件。\n在大部分情况下，频道是某一事件所定义的信息。因此即使Channel重名，在多个事件之间也不会冲突。\n重载频道 允许一个Object继承IDidaEventChannelInterface，重写接口的ReplaceObjectChannel即可改变计算Channel的方式，需要注意如果函数返回值为false，仍会以默认方式转换。\n比如可以定义Controller的计算转为以PlayerId来标识，这样也可以方便实现跨端的Channel交互。\n目前提供的特殊计算记录在：特殊Channel规则汇总\n需要注意如果Channel动态，则会导致依赖Channel的对应逻辑必须处理好先后顺序等问题。\n魔法频道 为了解决监听器必须要在Runtime时才能指定频道，这会导致默认值设置事件监听适用性变小。\n引入了一套魔法频道机制来解决一部分非Runtime指定频道的问题，当然也同样适用于Runtime时直接设置。\n其基础原理为：设定一类特殊的Name，创建监听时判断如果是这些Name则自动换成另外的Channel。\n因此可以直接在默认值设置时便填入这些魔法Channel，从而避免在Runtime时手动指定。\n需要注意注册时机与相关魔法频道依赖对象之间的先后关系，避免创建监听时所需对象不存在。\n","date":"2024-11-03","id":9,"permalink":"/zh/docs/concept/channel/","summary":"\u003ch2 id=\"机制说明\"\u003e机制说明\u003c/h2\u003e\n\u003cp\u003e为了解决某些监听器不是需要监听所有某一事件的触发，所以引入了频道Channel机制。\u003c/p\u003e\n\u003cp\u003e思路上只有注册与广播相同Channel的事件会被触发（不指定Channel应所有都触发）。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInvoke一个None，所有Listen都会被触发（无论Listen有没有指定Channel）\u003c/li\u003e\n\u003cli\u003eInvoke一个Channel，相同Channel的Listen会被触发\u003c/li\u003e\n\u003cli\u003eListen一个None，所有Invoke都会接收（无论Invoke有没有指定Channel）\u003c/li\u003e\n\u003cli\u003eListen一个Channel，相同Channel的Invoke会接收\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"频道分配\"\u003e频道分配\u003c/h2\u003e\n\u003cp\u003e对应的提供了如何使用Object来动态生成Channel的接口UDidaEventLibrary::GetObjectChannel。\u003c/p\u003e\n\u003cp\u003e默认情况下只要传入相同的对象，该函数会返回相同的Key，从而可以实现可以指定监听来自同一频道的事件。\u003c/p\u003e\n\u003cp\u003e在大部分情况下，频道是某一事件所定义的信息。因此即使Channel重名，在多个事件之间也不会冲突。\u003c/p\u003e\n\u003ch2 id=\"重载频道\"\u003e重载频道\u003c/h2\u003e\n\u003cp\u003e允许一个Object继承IDidaEventChannelInterface，重写接口的ReplaceObjectChannel即可改变计算Channel的方式，需要注意如果函数返回值为false，仍会以默认方式转换。\u003c/p\u003e\n\u003cp\u003e比如可以定义Controller的计算转为以PlayerId来标识，这样也可以方便实现跨端的Channel交互。\u003c/p\u003e\n\u003cp\u003e目前提供的特殊计算记录在：特殊Channel规则汇总\u003c/p\u003e\n\u003cdiv class=\"callout callout-caution d-flex flex-row mt-4 mb-4 pt-4 pe-4 pb-2 ps-3\"\u003e\r\n  \u003csvg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  width=\"24\"\n  height=\"24\"\n  viewBox=\"0 0 24 24\"\n  fill=\"none\"\n  stroke=\"currentColor\"\n  stroke-width=\"2\"\n  stroke-linecap=\"round\"\n  stroke-linejoin=\"round\"\n \n class=\"outline/alert-triangle svg-inline callout-icon me-2 mb-3\" id=\"svg-alert-triangle\" role=\"img\"\u003e\n  \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"/\u003e\n  \u003cpath d=\"M12 9v4\" /\u003e\n  \u003cpath d=\"M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z\" /\u003e\n  \u003cpath d=\"M12 16h.01\" /\u003e\n\u003c/svg\u003e\r\n  \u003cdiv class=\"callout-content\"\u003e\r\n    \r\n    \u003cdiv class=\"callout-body\"\u003e\r\n      \u003cp\u003e需要注意如果Channel动态，则会导致依赖Channel的对应逻辑必须处理好先后顺序等问题。\u003c/p\u003e","tags":[],"title":"事件频道"},{"content":"基础使用 载荷Payload用于事件触发时附带的额外参数，通过继承UDidaEventPayload来定义。\n触发时，通过结点设置载荷参数。\n监听时，通过Cast成目标类型来获取载荷参数。\n生成载荷 如果因为自身需求不能使用K2Node自动实例化Payload，可以调用事件的函数库中的静态函数来自己实例化一个Payload，相关函数为：UDidaEventLibrary::SpawnDidaEventPayload，然后使用函数库中的静态函数UDidaEventLibrary::InvokeEvent在触发事件即可。\n重载解析 Payload允许重载以下两个函数：\n参数 描述 MakeString 根据载荷数据生成字符串 LoadString 从字符串中赋值载荷数据 他们会在RPC与TCP收发事件时被调用，用作编码载荷的数据。\n目前默认会根据反射信息把数据生成一个Json字符串，但对于指针等特殊类型，需要自己定义一个编码与解码的逻辑，实现相关函数后，便能实现无感知的在网络上发送事件。\n载荷回收 为了优化生成载荷的开销，所以提供了载荷的回收。为了避免未正确实现回收函数而造成的异常，所以默认关闭了载荷的回收。如果需要开启，则可以创建一个基于UDidaEventPayloadRecyclable的子类，并实现NativeOnRecycled或K2_OnRecycled。\n载荷会在创建时尝试从回收池中获取，在事件Invoke后回收。\n需要正确实现载荷的回收函数避免调用异常或长时间持有对象，同时应避免在回收后继续使用载荷。\n","date":"2024-11-03","id":10,"permalink":"/zh/docs/concept/payload/","summary":"\u003ch2 id=\"基础使用\"\u003e基础使用\u003c/h2\u003e\n\u003cp\u003e载荷Payload用于事件触发时附带的额外参数，通过继承UDidaEventPayload来定义。\u003c/p\u003e\n\u003cp\u003e触发时，通过结点设置载荷参数。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/concept-invoke-payload_hu1276233845258907778.webp\"\r\n  width=\"384\"\r\n  height=\"442\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"concept-invoke-payload\"id=\"h-rh-i-0\"\r\n/\u003e\u003c/p\u003e\n\u003cp\u003e监听时，通过Cast成目标类型来获取载荷参数。\u003c/p\u003e\n\u003cp\u003e\r\n\r\n\u003cimg\r\n  src=\"/images/concept-payload-cast_hu10532882097624435871.webp\"\r\n  width=\"734\"\r\n  height=\"192\"\r\n  decoding=\"async\"\r\n  fetchpriority=\"auto\"\r\n  loading=\"lazy\"\r\n  alt=\"concept-payload-cast\"id=\"h-rh-i-1\"\r\n/\u003e\u003c/p\u003e\n\u003ch2 id=\"生成载荷\"\u003e生成载荷\u003c/h2\u003e\n\u003cp\u003e如果因为自身需求不能使用K2Node自动实例化Payload，可以调用事件的函数库中的静态函数来自己实例化一个Payload，相关函数为：UDidaEventLibrary::SpawnDidaEventPayload，然后使用函数库中的静态函数UDidaEventLibrary::InvokeEvent在触发事件即可。\u003c/p\u003e\n\u003ch2 id=\"重载解析\"\u003e重载解析\u003c/h2\u003e\n\u003cp\u003ePayload允许重载以下两个函数：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e参数\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMakeString\u003c/td\u003e\n          \u003ctd\u003e根据载荷数据生成字符串\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eLoadString\u003c/td\u003e\n          \u003ctd\u003e从字符串中赋值载荷数据\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e他们会在RPC与TCP收发事件时被调用，用作编码载荷的数据。\u003c/p\u003e\n\u003cp\u003e目前默认会根据反射信息把数据生成一个Json字符串，但对于指针等特殊类型，需要自己定义一个编码与解码的逻辑，实现相关函数后，便能实现无感知的在网络上发送事件。\u003c/p\u003e\n\u003ch2 id=\"载荷回收\"\u003e载荷回收\u003c/h2\u003e\n\u003cp\u003e为了优化生成载荷的开销，所以提供了载荷的回收。为了避免未正确实现回收函数而造成的异常，所以默认关闭了载荷的回收。如果需要开启，则可以创建一个基于UDidaEventPayloadRecyclable的子类，并实现NativeOnRecycled或K2_OnRecycled。\u003c/p\u003e","tags":[],"title":"事件载荷"},{"content":"","date":"2024-11-03","id":11,"permalink":"/zh/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":12,"permalink":"/zh/","summary":"","tags":[],"title":"DidaEvent"},{"content":"","date":"0001-01-01","id":13,"permalink":"/zh/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":14,"permalink":"/zh/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":15,"permalink":"/zh/tags/","summary":"","tags":[],"title":"Tags"}]